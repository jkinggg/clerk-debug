{"version":3,"file":"query-cache.js","names":["_utils","require","QueryCache","_map","Map","_proto","prototype","getByQuery","rxQuery","stringRep","toString","has","set","get","exports","createQueryCache","uncacheRxQuery","queryCache","uncached","delete","countRxQuerySubscribers","refCount$","observers","length","DEFAULT_TRY_TO_KEEP_MAX","DEFAULT_UNEXECUTED_LIFETIME","defaultCacheReplacementPolicyMonad","tryToKeepMax","unExecutedLifetime","_collection","size","minUnExecutedLifetime","now","maybeUncache","queriesInCache","Array","from","values","_lastEnsureEqual","_creationTime","push","mustUncache","sortedByLastUsage","sort","a","b","toRemove","slice","forEach","defaultCacheReplacementPolicy","COLLECTIONS_WITH_RUNNING_CLEANUP","WeakSet","triggerCacheReplacement","rxCollection","add","nextTick","then","requestIdlePromise","destroyed","cacheReplacementPolicy","_queryCache"],"sources":["../../src/query-cache.ts"],"sourcesContent":["/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport type {\n    RxQuery,\n    RxCacheReplacementPolicy,\n    RxCollection\n} from './types';\nimport {\n    nextTick,\n    now,\n    requestIdlePromise\n} from './plugins/utils';\n\nexport class QueryCache {\n    public _map: Map<string, RxQuery> = new Map();\n\n    /**\n     * check if an equal query is in the cache,\n     * if true, return the cached one,\n     * if false, save the given one and return it\n     */\n    getByQuery(rxQuery: RxQuery): RxQuery {\n        const stringRep = rxQuery.toString();\n        if (!this._map.has(stringRep)) {\n            this._map.set(stringRep, rxQuery);\n        }\n        return this._map.get(stringRep) as RxQuery;\n    }\n}\n\nexport function createQueryCache() {\n    return new QueryCache();\n}\n\n\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\n    rxQuery.uncached = true;\n    const stringRep = rxQuery.toString();\n    queryCache._map.delete(stringRep);\n\n}\n\n\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\n    return rxQuery.refCount$.observers.length;\n}\n\n\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport const DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport const defaultCacheReplacementPolicyMonad: (\n    tryToKeepMax: number,\n    unExecutedLifetime: number\n) => RxCacheReplacementPolicy = (\n    tryToKeepMax,\n    unExecutedLifetime\n) => (\n    _collection: RxCollection,\n    queryCache: QueryCache\n) => {\n    if (queryCache._map.size < tryToKeepMax) {\n        return;\n    }\n\n    const minUnExecutedLifetime = now() - unExecutedLifetime;\n    const maybeUncache: RxQuery[] = [];\n\n    const queriesInCache = Array.from(queryCache._map.values());\n    for (const rxQuery of queriesInCache) {\n        // filter out queries with subscribers\n        if (countRxQuerySubscribers(rxQuery) > 0) {\n            continue;\n        }\n        // directly uncache queries that never executed and are older then unExecutedLifetime\n        if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n            uncacheRxQuery(queryCache, rxQuery);\n            continue;\n        }\n        maybeUncache.push(rxQuery);\n    }\n\n    const mustUncache = maybeUncache.length - tryToKeepMax;\n    if (mustUncache <= 0) {\n        return;\n    }\n\n    const sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n    const toRemove = sortedByLastUsage.slice(0, mustUncache);\n    toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\n\n\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\n    DEFAULT_TRY_TO_KEEP_MAX,\n    DEFAULT_UNEXECUTED_LIFETIME\n);\n\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(\n    rxCollection: RxCollection\n) {\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n        // already started\n        return;\n    }\n\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n    /**\n     * Do not run directly to not reduce result latency of a new query\n     */\n    nextTick() // wait at least one tick\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n        .then(() => {\n            if (!rxCollection.destroyed) {\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n            }\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n        });\n}\n"],"mappings":"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"}